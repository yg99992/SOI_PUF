/*
 * puf_def.c
 *
 *  Created on: 2019ï¿½ï¿½10ï¿½ï¿½10ï¿½ï¿½
 *      Author: Chongchong Xu
 */
#include <stdio.h>
#include <stdlib.h>
#include "platform.h"
#include "xil_types.h"
#include "xil_io.h"
#include "xparameters.h"
#include "sleep.h"
#include "xuartps_hw.h"
#include "xsdps.h"		/* SD device driver */
#include "xil_printf.h"
#include "ff.h"
#include "xil_cache.h"
#include "xstatus.h"
#include "xgpiops.h"
#include "puf_def.h"
#include "keccak-tiny.h"
#include "sd_fun.h"
#include "soi_puf.h"


//#define TRNG_V1
//#define TRNG_V2_W2
//#define TRNG_V2_W3
#define TRNG_V2_W4

static FIL fil;		/* File object */
static FATFS fatfs;
FRESULT f_res;
UINT NumBytesWritten;

static char *SD_File;

u8 FILTER_CNT = 0; // Mean filter Repeat 2^FILTER_CNT times

puf_chaotic* puf_line4[6];
puf_chaotic* puf_line8[6];
int gen_trng(puf_chaotic* puf_hw, u32 dat_num, char* file_name);
int gen_trng_xor(puf_chaotic* puf_hw, u32 dat_num, char* file_name, u8 cnt_th);
int gen_trng_xor_add_test(puf_chaotic* puf_hw, u32 dat_num, char* file_name, u8 cnt_th);
static inline void chaotic_read_once_trng_8(puf_chaotic* puf_hw, u16* chal_dat, u32* resp_xor, u32* meta_val, u8* meta_cnt);

int double_metastable_eval(puf_chaotic* puf_hw, u32 dat_num, char* file_name);
int double_metastable_count_store(puf_chaotic* puf_hw, u32 dat_num, u8 puf_primitive, char* file_name);
int double_metastable_filtered_count_store(puf_chaotic* puf_hw, u32 dat_num, u8 puf_primitive);
void trng_throughput_eval(puf_chaotic* puf_hw, u32 dat_num);
static inline u8 chaotic_read_once_trng_selected(puf_chaotic* puf_hw, u16* chal_dat, u8 puf_primitive);
static inline u8 chaotic_read_counter_resp_selected(puf_chaotic* puf_hw, u32* resp_dat, u8 puf_primitive);
int meta_chal_gen(puf_chaotic* puf_hw, u16* chal_dat, u8 cnt_th);
int gen_trng_xor_throughput(puf_chaotic* puf_hw, u32 dat_num);

int chaotic_test()
{
	u16* chal_dat;
	u16* chal_dat_stable[4];
	u8 i,j;
	u32 crp_num = 1000;
	u16 rpt_cnt  = 2;
	char file_name[50] = "A4PxUx.dat";

	puf_line4[0] = (puf_chaotic*)PUF40_BASE_ADDR;
	puf_line4[1] = (puf_chaotic*)PUF41_BASE_ADDR;
	puf_line4[2] = (puf_chaotic*)PUF42_BASE_ADDR;
	puf_line4[3] = (puf_chaotic*)PUF43_BASE_ADDR;
	puf_line4[4] = (puf_chaotic*)PUF44_BASE_ADDR;
	puf_line4[5] = (puf_chaotic*)PUF45_BASE_ADDR;

	puf_line8[0] = (puf_chaotic*)PUF80_BASE_ADDR;
	puf_line8[1] = (puf_chaotic*)PUF81_BASE_ADDR;
	puf_line8[2] = (puf_chaotic*)PUF82_BASE_ADDR;
	puf_line8[3] = (puf_chaotic*)PUF83_BASE_ADDR;
	puf_line8[4] = (puf_chaotic*)PUF84_BASE_ADDR;
	puf_line8[5] = (puf_chaotic*)PUF85_BASE_ADDR;

    if(sd_init() != 0)
    	return -1;

    soi_test();
    //puf_line8[0]->reg3 = CLK12d5M;
    //puf_line8[0]->reg3 = CLK5M;

    //double_metastable_eval(puf_line8[0], 1000000, "META.dat");
    //gen_trng_xor(puf_line8[0], 100000000, "TRGN4.dat", 4);

    //gen_trng_xor_add_test(puf_line8[0], 100000000, "TC3.dat", 8);

    //double_metastable_count_store(puf_line8[0], 100000, 0, "10MP0.dat");
    //trng_throughput_eval(puf_line8[0], 100000000);
    //double_metastable_filtered_count_store(puf_line8[0], 10000000, 7);

	return 0;
}

/////// TRNG throughput evaluation
void trng_throughput_eval(puf_chaotic* puf_hw, u32 dat_num)
{
	int i,j;
	char file_name[10] = "CXMPX.dat";

	for(i=3; i<=9; i++){
		puf_hw->reg3 = i; // set the clock frequency
		file_name[1]	= '0' + i;
		for(j=0; j<8; j++){
			file_name[4]	= '0' + j;
			double_metastable_count_store(puf_hw, dat_num, j, file_name);
		}
	}
}


/******************************************
 * generate TRNG data
 * all counter bits are XORed and all counters values are XORed
 * ****************************************/
static inline void chaotic_read_once_trng(puf_chaotic* puf_hw, u16* chal_dat, u32* resp_xor, u32* meta_val, u8* meta_cnt);
int gen_trng(puf_chaotic* puf_hw, u32 dat_num, char* file_name)
{
	u16 chal_dat[4];
	int i;
	u32 loop;
	u32 resp_xor;
	u32 meta_val;
	u8 meta_cnt[16];
	u8 meta_max = 0, meta_max_inx = 0;
	u8 cnt_th = 63;
	unsigned short int * trng;
	unsigned short int * trng_xor;

	//srand(100);
	srand(10);

	// select the challenges with the count value larger than cnt_th
	while(meta_max < cnt_th){
		chal_dat[0] = rand();
		chal_dat[1] = rand();
		chal_dat[2] = rand();
		chal_dat[3] = rand();
		chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
		for(i=0; i<16; i++){  // find out the max value of all the 16 counters
			if(meta_max < meta_cnt[i]){
				meta_max = meta_cnt[i];
				meta_max_inx = i;  // record the index of max value
			}
		}
	}

	///////////// used for debug //////////////
	u8 trng_dat[100];
	for(i=0; i<100; i++){
		chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
		trng_dat[i] = meta_cnt[meta_max_inx];
	}
	///////////////////////////////////////////


	trng = (u16 *)malloc(sizeof(u16) * dat_num);
	if(trng == NULL) return -1;
	else memset((void *)trng, 0, sizeof(u16) * dat_num);

	trng_xor = (u16 *)malloc(sizeof(u16) * dat_num);
	if(trng_xor == NULL) return -1;
	else memset((void *)trng_xor, 0, sizeof(u16) * dat_num);

	for(i = 0; i < dat_num; i++){

		chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
		for(loop = 0; loop<7; loop++){   // All bits are xor
			*(trng + i) ^= (meta_cnt[meta_max_inx] >> loop);
		}
		*(trng + i) &= 0x0001;  // resolve the final bit

		for(loop = 0; loop<16; loop++){  // All count value are xor
			*(trng_xor + i) ^= meta_cnt[loop];
		}
		*(trng_xor + i) &= 0x0001;


		/*file_name[5] = rpt_i + '0';
		file_name[4] = 'X';
		array_store_file(file_name,  (unsigned int *)resp_xor,  crp_num, 1, 0);*/
	}

	file_name[0] = 'T';
	array_store_file_short(file_name,  (unsigned short int *)trng,  dat_num, 1, 1); //write and close file
	file_name[0] = 'X';
	array_store_file_short(file_name,  (unsigned short int *)trng_xor,  dat_num, 1, 1); //write and close file

	free(trng); trng = NULL;
	free(trng_xor); trng_xor = NULL;
	return 0;
}

/******************************************
 * generate TRNG data with all counters are xor
 * ****************************************/
int gen_trng_xor(puf_chaotic* puf_hw, u32 dat_num, char* file_name, u8 cnt_th)
{
	u16 chal_dat[4];
	int i;
	u32 loop;
	u32 resp_xor;
	u32 meta_val;
	u8 meta_cnt[16];
	u8 * trng_xor;

	trng_xor = (u8 *)malloc(sizeof(u8) * dat_num);
	if(trng_xor == NULL) return -1;
	else memset((void *)trng_xor, 0, sizeof(u8) * dat_num);

	meta_chal_gen(puf_hw, chal_dat, cnt_th);

	// collect data
	for(i = 0; i < dat_num; i++){
		chaotic_read_once_trng_8(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
#ifdef TRNG_V1
		for(loop = 0; loop<8; loop++){  // All count value are xor or added
			*(trng_xor + i) ^= meta_cnt[loop*2];   //  xor result
		}
#else
		*(trng_xor + i) = meta_cnt[0];
#endif
		//*(trng_xor + i) &= 0x0001;
	}


	//array_store_file_char(file_name,  trng_xor,  dat_num, 3, 1); //write and close file
	array_store_binfile_char(file_name,  trng_xor,  dat_num, 1); //write and close file
	//array_store_file_short(file_name,  (unsigned short int *)trng_xor,  dat_num, 3, 1); //write and close file

	free(trng_xor); trng_xor = NULL;
	return 0;
}

/////// XOR and ADD TRNG throughput evaluation
int gen_trng_xor_throughput(puf_chaotic* puf_hw, u32 dat_num)
{
	u16 chal_dat[4];
	int i;
	u32 loop;
	u32 resp_xor;
	u32 meta_val;
	u32 reg3_bak;
	u8 meta_cnt[16];
	u8 * trng_xor;
	u8 thp;
	char file_name[10] = "XORC0.dat";

	trng_xor = (u8 *)malloc(sizeof(u8) * dat_num);
	if(trng_xor == NULL) return -1;
	else memset((void *)trng_xor, 0, sizeof(u8) * dat_num);

	meta_chal_gen(puf_hw, chal_dat, 8);

	reg3_bak = puf_hw->reg3;  // save the initial status of reg3
	for(thp = 0; thp<=9; thp++){
		puf_hw->reg3 = thp;  // set throughput

		// collect data
		for(i = 0; i < dat_num; i++){
			chaotic_read_once_trng_8(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);

			for(loop = 0; loop<8; loop++){  // All count value are xor or added
				*(trng_xor + i) ^= meta_cnt[loop*2];   //  xor result
			}
		}

		file_name[4] = thp + '0';
		array_store_file_char(file_name,  trng_xor,  dat_num, 3, 1); //write and close file
	}

	puf_hw->reg3 = reg3_bak;  // restore the initial status of reg3
	free(trng_xor); trng_xor = NULL;
	return 0;
}

/******************************************
 * generate metastable challenge meeting the threshold
 * ****************************************/
static inline unsigned char meta_sum_calculate(u32 meta_val);
int meta_chal_gen(puf_chaotic* puf_hw, u16* chal_dat, u8 cnt_th)
{
	u8 meta_sum = 0;
	u32 resp_xor;
	u32 meta_val;
	u8 meta_cnt[16];
	u8 tmp_cnt;
	int i;

	srand(10);

	// select the challenges with the number of metastable PUF larger than cnt_th
	while(1){
		chal_dat[0] = rand();
		chal_dat[1] = rand();
		chal_dat[2] = rand();
		chal_dat[3] = rand();
		chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
#ifdef TRNG_V1
		meta_sum = meta_sum_calculate(meta_val);
		if(meta_sum != cnt_th)
			continue;
		else{
			tmp_cnt = 0;
			for(i=0; i<16; i++){ // repeat 16 times
				chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
				if(meta_sum_calculate(meta_val) == cnt_th)
					tmp_cnt ++;
			}
			if(tmp_cnt >=8) // if 'meta_val == cnt_th' happens 8 times, break and return challenge
				break;
		}
#else
		meta_sum = meta_val;
		if(meta_sum != cnt_th)
			continue;
		else{
			tmp_cnt = 0;
			for(i=0; i<16; i++){ // repeat 16 times
				chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
				if((u8)meta_val == cnt_th)
					tmp_cnt ++;
			}
			if(tmp_cnt >=8) // if 'meta_val == cnt_th' happens 8 times, break and return challenge
				break;
		}
#endif
	}
	return 0;
}

static inline unsigned char meta_sum_calculate(u32 meta_val)
{
	int i;
	unsigned char res = 0;

	for(i=0; i<8; i++){  // calculate the number of metastable PUF primitive
		res += ((meta_val>>(i*2)) & 0x00000001);
	}
	return res;
}



///////// Store the filtered counter value of challenges into sd card.
///////// The mean value of counter range from 20 to 150 with 5 step.
///////// Only read one of the two counters in Arbiter
int double_metastable_filtered_count_store(puf_chaotic* puf_hw, u32 dat_num, u8 puf_primitive)
{
	u16 chal_dat[4];
	int i;
	u32 resp_xor;
	u32 meta_val;
	u8 meta_cnt[16];
	u8 cnt_th=0;
	u16 cnt_val = 0;
	char file_name[9] = "C000.DAT";

	unsigned short int * trng;
	trng = (u16 *)malloc(sizeof(u16) * dat_num);
	if(trng == NULL) return -1;
	else memset((void *)trng, 0, sizeof(u16) * dat_num);

	for(cnt_th = 5; cnt_th<=150; cnt_th+=5){
		srand(10);
		file_name[1] = '0'+ (u8)(cnt_th / 100);
		file_name[2] = '0'+ (u8)((cnt_th % 100)/10);
		file_name[3] = '0'+ (u8)(cnt_th % 10);

		/**/
		// select the challenge with the count value located in cnt_th ~ cnt_th+5
		while( (cnt_val < cnt_th-2) || (cnt_val > (cnt_th+2))){
			chal_dat[0] = rand();
			chal_dat[1] = rand();
			chal_dat[2] = rand();
			chal_dat[3] = rand();
			chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
			cnt_val = meta_cnt[2*puf_primitive];

			if(cnt_val !=0){// mean filter
				cnt_val = 0;
				for(i=0; i<=15; i++){
					chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
					cnt_val += meta_cnt[2*puf_primitive];
				}
				cnt_val = cnt_val >> 4;
			}
		}

		/* read counter values and store it into SD card*/
		for(i=0; i<dat_num; i++){
			*(trng+i) = chaotic_read_once_trng_selected(puf_hw,   chal_dat, puf_primitive);
		}
		file_name[0] = 'C';
		array_store_file_short(file_name,  (unsigned short int *)trng,  dat_num, 3, 1); //write and close file


		/* read response values and store it into SD card*/
		for(i=0; i<dat_num; i++){
			chaotic_read_counter_resp_selected(puf_hw,   &resp_xor, puf_primitive);
			*(trng+i) = (u16) resp_xor;
		}
		file_name[0] = 'R';
		array_store_file_short(file_name,  (unsigned short int *)trng,  dat_num, 1, 1); //write and close file
	}

	free(trng);
	trng = NULL;
	return 0;
}


///////// store the counter value of random challenges into sd card
int double_metastable_count_store(puf_chaotic* puf_hw, u32 dat_num, u8 puf_primitive, char* file_name)
{
	u16 chal_dat[4];
	int i;
	u32 resp_xor;
	u32 meta_val;
	u8 meta_cnt[16];

	//srand(100);
	srand(10);

	unsigned short int * trng;
	trng = (u16 *)malloc(sizeof(u16) * dat_num*2);
	if(trng == NULL) return -1;
	else memset((void *)trng, 0, sizeof(u16) * dat_num * 2);

	for(i=0; i<dat_num; i++){
		chal_dat[0] = rand();
		chal_dat[1] = rand();
		chal_dat[2] = rand();
		chal_dat[3] = rand();
		chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
		*(trng+i*2) 	= meta_cnt[2*puf_primitive];
		*(trng+i*2 + 1) = meta_cnt[2*puf_primitive + 1];
	}
	array_store_file_short(file_name,  (unsigned short int *)trng,  dat_num *2, 3, 1); //write and close file
	return 0;

	free(trng);
	trng = NULL;
}

///////// store the meta signal of random challenges into sd card
int double_metastable_eval(puf_chaotic* puf_hw, u32 dat_num, char* file_name)
{
	u16 chal_dat[4];
	int i;
	u32 resp_xor;
	u32 meta_val;
	u8 meta_cnt[16];

	//srand(100);
	srand(10);

	unsigned short int * trng;
	trng = (u16 *)malloc(sizeof(u16) * dat_num);
	if(trng == NULL) return -1;
	else memset((void *)trng, 0, sizeof(u16) * dat_num);

	for(i=0; i<dat_num; i++){
		chal_dat[0] = rand();
		chal_dat[1] = rand();
		chal_dat[2] = rand();
		chal_dat[3] = rand();
		chaotic_read_once_trng(puf_hw,   chal_dat, &resp_xor, &meta_val, meta_cnt);
		*(trng+i) = (u16)meta_val;
	}
	array_store_file_short(file_name,  (unsigned short int *)trng,  dat_num, 6, 1); //write and close file

	free(trng);
	trng = NULL;
	return 0;
}



///////////////////////////////////////////////////////////
//  Randomly generate challenges
///////////////////////////////////////////////////////////
u16* chal_gen(u32 num)
{
	u16 * chal_dat;
	u32 loop, cnt_16;

	cnt_16 = num * 4;
	chal_dat = (u16 *)malloc(cnt_16 * sizeof(u16));
	if(chal_dat == NULL)
		return chal_dat;
	srand(100);
	for(loop = 0; loop < cnt_16; loop++){
		*(chal_dat + loop) = rand();
	}
	return chal_dat;
}

///////////////////////////////////////////////////////////
//  Generate stable challenges
///////////////////////////////////////////////////////////
/**/
u16* chal_gen_stabe(puf_chaotic* puf_hw, u32 num)
{
	u16 * chal_dat;
	u32 loop, cnt_16;
	u32 tmp, fail_cnt = 0, resp;


	cnt_16 = num * 4;
	chal_dat = (u16 *)malloc(cnt_16 * sizeof(u16));
	if(chal_dat == NULL)
		return chal_dat;
	srand(100);

	for(loop = 0; loop < cnt_16; ){
		*(chal_dat + loop  ) = rand();
		*(chal_dat + loop+1) = rand();
		*(chal_dat + loop+2) = rand();
		*(chal_dat + loop+3) = rand();
		chaotic_read_calibration(puf_hw,   chal_dat + loop, &resp, &tmp);

		if(tmp ==1){   // unstable
			fail_cnt += 1;
		}else{
			loop += 4;
		}

	}
	return chal_dat;
}

